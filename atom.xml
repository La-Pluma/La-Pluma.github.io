<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LaPluma</title>
  
  <subtitle>Keep it simple and stupid.</subtitle>
  <link href="http://la-pluma.github.io/atom.xml" rel="self"/>
  
  <link href="http://la-pluma.github.io/"/>
  <updated>2024-09-21T18:20:42.472Z</updated>
  <id>http://la-pluma.github.io/</id>
  
  <author>
    <name>LaPluma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode个人题解[C++] P4 寻找两个正序数组的中位数</title>
    <link href="http://la-pluma.github.io/2024/09/21/LeetCode-P4/"/>
    <id>http://la-pluma.github.io/2024/09/21/LeetCode-P4/</id>
    <published>2024-09-21T12:29:30.000Z</published>
    <updated>2024-09-21T18:20:42.472Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接:</strong> <ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/"><strong>LeetCode|4.寻找两个正序数组的中位数</strong></a></p><span id="more"></span><hr /><h2 id="题面解释">题面解释</h2><p>找出两个有序数组合并后的中位数. 但要求时间复杂度<spanclass="math inline">\(\mathit{O}(log(m + n))\)</span>.</p><h2 id="解法一-二分">解法一 二分</h2><p>笔者看到复杂度<span class="math inline">\(\mathit{O}(log(m +n))\)</span>第一想法便是二分, 但怎么二分? 两个数组只是内部有序,两个数组并不有序, 常规对数组二分的思路肯定是不行的.</p><p>那该如何进行二分呢, 对答案进行二分. 令k为所寻找的k阶数, 初始为中位数,则此时我们取两个数组的前<spanclass="math inline">\(k/2\)</span>部分出来, 比较<spanclass="math inline">\(nums1[k/2]\)</span>和<spanclass="math inline">\(nums2[k/2]\)</span>, 则可以直接排除<spanclass="math inline">\(k/2\)</span>个数. 我们以下图例子来解释.</p><img src="/2024/09/21/LeetCode-P4/p1.png" class="" title="p1"><p><span class="math inline">\(m = n = 4\)</span>, 我们有 <spanclass="math inline">\(k = 4, k/2 = 2\)</span>,于是我们取两个数组的前两位, 比较3和5, 不难看出, 1和3不可能是中位数.为什么? 因为1和3的阶必定小于<span class="math inline">\(k = 4\)</span>,即便第一个数组的3比第二个数组的5前面所有数都大, 3的阶也只能是3,1就更不必说了. 而5前面的数可能大于3后面的数(例子中未能体现,读者可以自行构造一个满足这种情况的简单例子). 因此通过这种操作,我们可以排掉 <span class="math inline">\(k/2\)</span>个不可能是中位数的元素, 接着我们令<span class="math inline">\(k = k -k/2\)</span>, 将被排除的数去掉, 重新进行上述过程.</p><img src="/2024/09/21/LeetCode-P4/p2.png" class="" title="p2"><p>选取两个数组的前1位.比较2 和 4, 可以排除掉2. 此时过程进行到了边界处,接下来<span class="math inline">\(k = 1\)</span>无法继续了.而此时剩下的4和5正是我们需要的中位数.</p><blockquote><p><strong>Tips:</strong> 为什么第二个数组不是选择2, 5, 7?</p><p>因为我们在上面的步骤中无法确定2和5是中位数与否, 此时的有效信息不足.而把2 5 7都放进来与4进行比较会出现bug, 以上例, 4会被错误的排除掉</p></blockquote><p>k为奇数时情况稍有不同, 但大多是一些细节问题, 笔者在此不再赘述.推荐读者自己构建一个例子去推算上面的过程, 相信不难理解其中要义.</p><p>每次排除<span class="math inline">\(k/2\)</span>, 而 <spanclass="math inline">\(k = (m + n + 1) / 2\)</span>, 故时间复杂度<spanclass="math inline">\(\mathit{O}(log(m + n))\)</span>.</p><p>参考代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; m; i++)&#123;cout &lt;&lt; nums1[i] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int j = 0; j &lt; n; j++)&#123;cout &lt;&lt; nums2[j] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = (m + n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// 排除掉小于中位数的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组被清空</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> mid = k &gt;&gt; <span class="number">1</span>; <span class="comment">// 注意循环条件 k &gt; 1</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid1 = left1 + mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> mid2 = left2 + mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 边界情况，剩余数组大小不足k</span></span><br><span class="line">            <span class="keyword">if</span> (left1 + mid &gt; m) &#123; <span class="comment">// 等价于 left1 + mid - 1 &gt;= m</span></span><br><span class="line">                mid1 = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 + mid &gt; n) &#123;</span><br><span class="line">                mid2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[mid1] &gt;= nums2[mid2]) &#123;</span><br><span class="line">                k -= mid2 - left2 + <span class="number">1</span>; <span class="comment">// 一轮可以排除掉一半</span></span><br><span class="line">                left2 = mid2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= mid1 - left1 + <span class="number">1</span>;</span><br><span class="line">                left1 = mid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 k == 1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                    left2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 别忘了处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> ((m + n) &amp; <span class="number">1</span> == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="built_in">return</span> (nums2[left2] + nums2[left2 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[left1] + nums1[left1 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num1;</span><br><span class="line">            <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                num1 = nums2[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = nums1[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num2;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                num2 = nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                num2 = nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num2 = <span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (num1 + num2) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tips:</strong> 本题思路并不难想出或者说并不难理解,但非常考验代码功底, 对细节和边界情况的考察更像是此题的侧重点.还望看到此处的读者能静下心来调试代码, 祝早日AC.</p></blockquote><h2 id="解法二-分割">解法二 分割</h2><blockquote><p>笔者阅读题解时注意到的巧妙的解法, 原链接在此<ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/"><strong>P4|windliang</strong></a></p></blockquote><p>更详细的数学证明, 思路和代码请阅读原文,笔者在此只给出自己对其的理解.</p><p>本质来说, 两种方法殊途同归, 但分割的方法较为巧妙一些. 中位数,或者说k阶数, 就是将数组分为两个部分, 其一是比k阶数小的部分,其二是比k阶数大的部分.</p><p>对于有序的一个数组, 其性质本身就已经满足,我们不妨将两部分简称为左半部分(小)和右半部分(大). 对于两个有序数组,情况是一样的, 如果存在一种划分, 满足左边最大MaxLeft小于右边最小MinRight,我们则认为这是关于k阶数的一种有效划分.</p><p>因此, 这道题就被转化为寻找数组中满足中位数的有效划分,关于特定k阶数划分, 还需要满足左半部分和右半部分的数量关系,若规定将k阶数划在左半部分, 则左半部分有k个元素, 右半部分有 n - k个元素.</p><p>后面的事情就简单了, 固定数组1的划分位置,根据数量关系找到数组2待判定划分位置,根据MaxLeft和MinRight的大小关系决定数组1划分位置的左移或右移,该过程可以通过二分完成.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目链接:&lt;/strong&gt; &lt;a
href=&quot;https://leetcode.cn/problems/median-of-two-sorted-arrays/&quot;&gt;&lt;strong&gt;LeetCode|4.寻找两个正序数组的中位数&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode刷题记录" scheme="http://la-pluma.github.io/categories/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="LeetCode" scheme="http://la-pluma.github.io/tags/LeetCode/"/>
    
    <category term="二分" scheme="http://la-pluma.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-机器学习 Part.1 Ch0-Ch1</title>
    <link href="http://la-pluma.github.io/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/"/>
    <id>http://la-pluma.github.io/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/</id>
    <published>2024-09-18T15:04:27.000Z</published>
    <updated>2024-09-22T15:08:04.800Z</updated>
    
    <content type="html"><![CDATA[<p><strong>机器学习所研究的主要内容,是关于在计算机上从数据中产生"模型"(model)的算法, 即"学习算法"(learningalgorithm).</strong></p><span id="more"></span><p><font size = 5><b>目录</b></font></p><ul><li><a href="#书籍基本信息">书籍基本信息</a></li><li><a href="#chapter-0-主要符号表">Chapter 0: 主要符号表</a></li><li><a href="#chapter-1-绪论">Chapter 1: 绪论</a><ul><li><a href="#11-基本术语">1.1 基本术语</a></li><li><a href="#13-假设空间">1.3 假设空间</a></li><li><a href="#14-归纳偏好">1.4 归纳偏好</a></li></ul></li></ul><hr /><h2 id="书籍基本信息">书籍基本信息</h2><p>《机器学习》周志华 2016.</p><p>大名鼎鼎的西瓜书, 笔者在此略去介绍.</p><h2 id="chapter-0-主要符号表">Chapter 0: 主要符号表</h2><p><span class="math display">\[\begin{aligned}&amp;\mathit{x}&amp; &amp;标量\\&amp;\boldsymbol{x}&amp; &amp;向量 \\&amp;\mathrm{x}&amp; &amp;变量集 \\&amp;\mathbf{A}&amp; &amp;矩阵 \\&amp;\mathbf{I}&amp; &amp;单位阵 \\&amp;\mathcal{X}&amp; &amp;样本空间或状态空间\\&amp;\mathcal{D}&amp; &amp;概率分布\\&amp;\mathit{D}&amp; &amp;数据样本(数据集)\\&amp;\mathcal{H}&amp; &amp;假设空间\\&amp;\mathit{H}&amp; &amp;假设集\\&amp;\mathfrak{L}&amp; &amp;学习算法\\&amp;\left ( \cdot ,\cdot ,\cdot  \right )&amp; &amp;行向量\\&amp;\left ( \cdot ;\cdot ;\cdot \right )&amp; &amp;列向量\\&amp;\left ( \cdot  \right )^{T}&amp; &amp;向量或矩阵转置\\&amp;\left \{  \cdot \cdot \cdot \right \}&amp; &amp;集合\\&amp;\left | \left \{ \cdot \cdot \cdot \right \} \right |&amp;&amp;集合中元素个数\\&amp;\left \| \cdot  \right \|_{p}&amp; &amp;L_p范数, p缺省时为L_2范数\\&amp;\mathit{P}\left ( \cdot  \right ),\mathit{P}\left ( \cdot|\cdot  \right )&amp; &amp;概率质量函数,条件概率质量函数\\&amp;\mathit{p}\left ( \cdot  \right ),\mathit{p}\left ( \cdot  | \cdot\right )&amp; &amp;概率密度函数, 条件概率密度函数\\&amp;\mathbb{E}_{\cdot \sim \mathcal{D}}\left [ f\! \left ( \cdot \right) \right ]&amp; &amp;函数 f\! \left ( \cdot \right ) 对 \cdot 在分布\mathcal{D} 下的数学期望:意义明确是将省略 \mathcal{D} 和(或)\cdot \\&amp;sup\left ( \cdot \right )&amp; &amp;上确界\\&amp;\mathbb{I}\! \left ( \cdot  \right )&amp; &amp;指示函数，在\cdot  为真和假分别取值为1 , 0 \\&amp;sign\left ( \cdot  \right )&amp; &amp;符号函数，在 \cdot &lt; 0, =0 , &gt;  0 时分别取值为 -1,0,1\end{aligned}\]</span></p><h2 id="chapter-1-绪论">Chapter 1: 绪论</h2><h3 id="基本术语">1.1 基本术语</h3><blockquote><p>假定我们收集了一批关于西瓜的数据, 例如(色泽 = 浅白; 根蒂 = 蜷缩; 敲声= 浊响), (色泽 = 乌黑; 根蒂 = 稍蜷; 敲声 = 沉闷), (色泽 = 浅白; 根蒂 =硬挺; 敲声 = 清脆), ......, 每对括号内是一条记录,下文关于术语的表述会基于上述假定进行解释.</p></blockquote><ul><li><p><strong>数据集/样本(Data Set):</strong>这组记录的集合称为一个数据集.</p><blockquote><p><strong>Tips:</strong> 数据集亦称样本,因为数据集可看作对样本空间的一个采样.</p><p><strong>Addtional:</strong> "样本"的具体指代示例还是数据集,要看具体的上下文.</p></blockquote></li><li><p><strong>示例(Instance)/样本(Sample):</strong>每条记录称为示例/样本, 是关于一个事件或对象的描述(以上例,该对象为西瓜).</p></li><li><p><strong>属性(Attribute)/特征(Feature):</strong> "色泽", "根蒂","敲声"称为属性.</p></li><li><p><strong>属性值(Attribute Value):</strong>属性的取值称为属性值(以上例, "青绿"和"乌黑"是色泽的属性值).</p></li><li><p><strong>属性空间(Attribute Space)/样本空间(SampleSpace)/输入空间:</strong> 属性张成的空间.</p><blockquote><p><strong>Tips:</strong> 此处涉及的是线性代数知识,即将样本(Instance)依据属性转化为向量, 其中色泽, 根蒂和敲声为坐标轴,张成了一个用于描述西瓜特征的三维空间,该空间每个点即是线性代数意义上的一个向量, 也就是<strong>特征向量(FeatureVector)</strong>. 我们可以认为,示例(Instance)的另一种等价表述是特征向量.</p></blockquote></li><li><p><strong>数据集的表示:</strong> 令 <spanclass="math inline">\(\mathit{D} = \{x_1, x_2, ..., x_m\}\)</span>表示包含<span class="math inline">\(m\)</span>个示例的数据集, 每个示例由<span class="math inline">\(d\)</span> 个属性描述, 则每个示例(Instance)<span class="math inline">\(x_i= (x_{i1}; x_{i2}; ...; x_{id})\)</span>是 <span class="math inline">\(d\)</span> 维样本空间 <spanclass="math inline">\(\mathcal{X}\)</span> 中的一个向量, <spanclass="math inline">\(x_i \in \mathcal{X}\)</span>. <spanclass="math inline">\(d\)</span> 称为样本 <spanclass="math inline">\(x_i\)</span>的<strong>维数(Dimensionality)</strong>.</p></li><li><p><strong>学习(Learning)/训练(Training):</strong>从数据中学得模型的过程称为学习/训练,该过程通过执行某个学习算法完成.</p></li><li><p><strong>训练数据(Training Data):</strong>训练过程中所使用的数据.</p></li><li><p><strong>训练样本(Training Sample)/训练示例(TrainingInstance):</strong> 训练数据中的每个样本/示例.</p></li><li><p><strong>训练集(Training Set):</strong>训练样本组成的集合称为训练集.</p><blockquote><p><strong>Tips:</strong> 训练集相当于训练数据的子集,训练数据除去<strong>训练集</strong>外还存在<strong>验证集</strong>.(参考自:<ahref="https://zhuanlan.zhihu.com/p/115344944"><strong>知乎|训练集(trainingdataset), 测试集(test dataset)与验证集(validationdataset)</strong></a>)</p></blockquote></li><li><p><strong>假设(Hypothesis)&amp;真相/真实(Ground-Truth):</strong>学得模型对应了关于数据的某种潜在规律,因此亦称假设.这种潜在规律称为"真相"/"真实".学习的过程就是为了找出或逼近真相.</p><blockquote><p><strong>Tips:</strong> <ahref="https://en.wikipedia.org/wiki/Ground_truth"><strong>WIKIPEDIA|Ground-Truth</strong></a>又将其表述为<strong>基准真相</strong>.</p><p>"Ground truth is information that is known to be real or true,provided by direct observation and measurement (i.e. empirical evidence)as opposed to information provided by inference."</p></blockquote></li></ul><p><strong>Tips:</strong>本书有时又将<strong>模型</strong>称为<strong>学习器(Learner)</strong>,模型可看作是学习算法在给定数据和参数空间上的实例化.</p><ul><li><p><strong>标记(Label):</strong> 关于示例(Instance)结果的信息,称为标记(如"好瓜"). 一般的, 用 <span class="math inline">\((x_i,y_i)\)</span> 表示第 <span class="math inline">\(i\)</span> 个样例, 其中<span class="math inline">\(y_i \in \mathcal{Y}\)</span> 是示例 <spanclass="math inline">\(x_i\)</span> 的标记, <spanclass="math inline">\(\mathcal{Y}\)</span> 是所有标记的集合,又称<strong>标记空间(Label Space)/输出空间</strong>.</p></li><li><p><strong>分类(Classification):</strong>若<strong>预测(Prediction)</strong>的是离散值(如"好瓜", "坏瓜"),则称此类学习任务是分类.</p></li><li><p><strong>回归(Regression):</strong> 若预测的是连续值(如成熟度0.95,0.7), 则称此类学习任务是回归.</p></li><li><p><strong>二分类(Binary Classification):</strong>只涉及两个类别的分类任务, 通常称其中一类为<strong>正类(PositiveClass)</strong>, 另一类为<strong>反类(Negative Class)</strong>.</p></li><li><p><strong>多分类(Multi-class Classification):</strong> 与之相对的,涉及多种类别的分类任务称为多分类任务.</p></li><li><p><strong>预测任务:</strong> 预测任务希望通过对训练集<spanclass="math inline">\(\{(x_1, y_1), (x_2, y_2), ..., (x_m,y_m)\}\)</span> 进行学习, 建立一个从输入空间 <spanclass="math inline">\(\mathcal{X}\)</span> 到输出空间 <spanclass="math inline">\(\mathcal{Y}\)</span> 的映射 <spanclass="math inline">\(f : \mathcal{X} \rightarrow \mathcal{Y}\)</span>.对二分类, 通常取 <span class="math inline">\(\mathcal{Y} = \{-1,1\}\)</span> 或 <span class="math inline">\(\{0, 1\}\)</span>;对于多分类, <span class="math inline">\(|\mathcal{Y}| &gt; 2\)</span>;对于回归, <span class="math inline">\(\mathcal{Y} =\mathbb{R}\)</span>.</p></li><li><p><strong>测试(Testing):</strong>使用学习得到的模型进行预测的过程称为测试,预测的样本称为<strong>测试样本(Testing Sample)/测试示例(TestingInstance)</strong>.</p></li><li><p><strong>聚类(Clustering):</strong> 将训练集中的样本分为若干组,每组称为一个<strong>簇(Cluster)</strong>.</p><blockquote><p><strong>Tips:</strong> 形成的簇可能对应一些潜在的概念划分(如本地瓜,外地瓜), 但这样的概念我们事先不知道,否则通过标记(Label)就可以形成簇划分.</p></blockquote></li><li><p><strong>监督学习(Supervised Learning)/有导师学习:</strong>训练数据拥有标记信息, 分类和回归为代表.</p></li><li><p><strong>无监督学习(Unsupervised Learning)/无导师学习</strong>训练数据无标记信息, 聚类为代表.</p></li></ul><blockquote><p><strong>Tips:</strong> 此处仅作最基本的概念了解,关于上述两概念的具体释义留及之后的学习.</p></blockquote><ul><li><p><strong>泛化(Generalization):</strong>学得模型适用于新样本的能力,称为泛化能力.</p><blockquote><p><strong>Tips1:</strong> 样本空间通常很大, 训练过程无法涵盖所有的示例,我们希望模型可以对新样本有较好的目标表现, 这就是泛化的意义.</p><p><strong>Tips2:</strong> 泛化的数学支撑:</p><p>关于这种泛化,我们通常假设样本空间中的所有样本都服从一个未知的<strong>分布(Distribution)</strong><span class="math inline">\(\mathcal{D}\)</span>,获取的样本是从该分布上采样获得的, 满足<strong>独立同分布(Independent andIdentically Distributed, <em>i.d.d</em>)</strong>.</p></blockquote></li></ul><h3 id="假设空间">1.3 假设空间</h3><p><strong>归纳(Induction)</strong>与<strong>演绎(Deduction)</strong>是科学推理的两大基本手段.</p><blockquote><p>前者是从特殊到一般的<strong>泛化(Generalization)</strong>过程;后者是从一般到特殊的<strong>特化(Specialization)</strong>过程.</p></blockquote><ul><li><p><strong>归纳学习(Inductive Learning):</strong>广义的归纳学习大体相当于从样例中学习,狭义的归纳学习要求从学习过程中习得<strong>概念(concept)</strong>,亦称<strong>概念学习/概念形成</strong>.</p></li><li><p><strong>版本空间(Version Space):</strong>存在一个与训练集一致的"假设集合", 称为版本空间, 例如:</p></li></ul><p><img src="BookNote-MachineLearning-by-ZhihuaZhou-1\table1-1.png"alt="table1-1" /></p><p>其假设空间为</p><p><img src="BookNote-MachineLearning-by-ZhihuaZhou-1\pic1-1.png"alt="pic1-1" /></p><p>其版本空间为</p><p><img src="BookNote-MachineLearning-by-ZhihuaZhou-1\pic1-2.png"alt="pic1-2" /></p><blockquote><p><strong>Tips:</strong> 在该数据集中, 好瓜具有的共同特征是蜷缩和浊响.因此色泽标识为通配符 <span class="math inline">\(*\)</span>, 同时,第一行的两种假设同样是与训练集一致的.</p></blockquote><h3 id="归纳偏好">1.4 归纳偏好</h3><ul><li><p><strong>归纳偏好(Inductive bias):</strong>算法在学习过程中对某种类型假设的偏好称为归纳偏好.</p><blockquote><p><strong>Tips:</strong><strong>任何</strong>一个有效的机器学习算法必有其归纳偏好,否则它无法产生确定的学习结果.</p><p>以图1-2的版本空间为例, 对新瓜(色泽=青绿;根蒂=蜷缩;敲声=沉闷),若模型告诉我们这种瓜时好时坏则没有意义,模型必须对给定的样本给予确定的结果.</p><p><strong>Additional:</strong>归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或"价值观".常遵循<strong>奥卡姆剃刀(Occam'sRazor)</strong>原则(<strong>若有多个假设与观察一致,则选简单的那个</strong>).</p></blockquote></li></ul><p>接下来我们来比较不同归纳偏好的优劣</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;机器学习所研究的主要内容,
是关于在计算机上从数据中产生&quot;模型&quot;(model)的算法, 即&quot;学习算法&quot;(learning
algorithm).&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://la-pluma.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="机器学习" scheme="http://la-pluma.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>千里之行，始于足下</title>
    <link href="http://la-pluma.github.io/2024/09/08/hello-world/"/>
    <id>http://la-pluma.github.io/2024/09/08/hello-world/</id>
    <published>2024-09-08T12:56:57.000Z</published>
    <updated>2024-09-12T15:49:07.668Z</updated>
    
    <content type="html"><![CDATA[<p><strong>A journey of a thousand miles begins with a singlestep.</strong></p><span id="more"></span><img src="/2024/09/08/hello-world/picture.png" class="" title="picture">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;A journey of a thousand miles begins with a single
step.&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://la-pluma.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="杂项" scheme="http://la-pluma.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
</feed>
