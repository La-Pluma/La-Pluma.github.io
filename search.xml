<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>读书笔记-机器学习 Part.1 Ch0-Ch1</title>
    <url>/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/</url>
    <content><![CDATA[<p><strong>机器学习所研究的主要内容,
是关于在计算机上从数据中产生"模型"(model)的算法, 即"学习算法"(learning
algorithm).</strong></p>
<span id="more"></span>
<p>
<font size = 5><b>目录</b></font>
</p>
<ul>
<li><a href="#书籍基本信息">书籍基本信息</a></li>
<li><a href="#chapter-0-主要符号表">Chapter 0: 主要符号表</a></li>
<li><a href="#chapter-1-绪论">Chapter 1: 绪论</a>
<ul>
<li><a href="#11-基本术语">1.1 基本术语</a></li>
<li><a href="#13-假设空间">1.3 假设空间</a></li>
<li><a href="#14-归纳偏好">1.4 归纳偏好</a></li>
</ul></li>
</ul>
<hr />
<h2 id="书籍基本信息">书籍基本信息</h2>
<p>《机器学习》周志华 2016.</p>
<p>大名鼎鼎的西瓜书, 笔者在此略去介绍.</p>
<h2 id="chapter-0-主要符号表">Chapter 0: 主要符号表</h2>
<p><span class="math display">\[\begin{aligned}
&amp;\mathit{x}&amp; &amp;标量\\
&amp;\boldsymbol{x}&amp; &amp;向量 \\
&amp;\mathrm{x}&amp; &amp;变量集 \\
&amp;\mathbf{A}&amp; &amp;矩阵 \\
&amp;\mathbf{I}&amp; &amp;单位阵 \\
&amp;\mathcal{X}&amp; &amp;样本空间或状态空间\\
&amp;\mathcal{D}&amp; &amp;概率分布\\
&amp;\mathit{D}&amp; &amp;数据样本(数据集)\\
&amp;\mathcal{H}&amp; &amp;假设空间\\
&amp;\mathit{H}&amp; &amp;假设集\\
&amp;\mathfrak{L}&amp; &amp;学习算法\\
&amp;\left ( \cdot ,\cdot ,\cdot  \right )&amp; &amp;行向量\\
&amp;\left ( \cdot ;\cdot ;\cdot \right )&amp; &amp;列向量\\
&amp;\left ( \cdot  \right )^{T}&amp; &amp;向量或矩阵转置\\
&amp;\left \{  \cdot \cdot \cdot \right \}&amp; &amp;集合\\
&amp;\left | \left \{ \cdot \cdot \cdot \right \} \right |&amp;
&amp;集合中元素个数\\
&amp;\left \| \cdot  \right \|_{p}&amp; &amp;L_p范数, p缺省时为L_2范数\\
&amp;\mathit{P}\left ( \cdot  \right ),\mathit{P}\left ( \cdot
|\cdot  \right )&amp; &amp;概率质量函数,条件概率质量函数\\
&amp;\mathit{p}\left ( \cdot  \right ),\mathit{p}\left ( \cdot  | \cdot
\right )&amp; &amp;概率密度函数, 条件概率密度函数\\
&amp;\mathbb{E}_{\cdot \sim \mathcal{D}}\left [ f\! \left ( \cdot \right
) \right ]&amp; &amp;函数 f\! \left ( \cdot \right ) 对 \cdot 在分布
\mathcal{D} 下的数学期望:意义明确是将省略 \mathcal{D} 和(或)\cdot \\
&amp;sup\left ( \cdot \right )&amp; &amp;上确界\\
&amp;\mathbb{I}\! \left ( \cdot  \right )&amp; &amp;指示函数，在
\cdot  为真和假分别取值为1 , 0 \\
&amp;sign\left ( \cdot  \right )&amp; &amp;符号函数，在 \cdot &lt; 0, =
0 , &gt;  0 时分别取值为 -1,0,1
\end{aligned}\]</span></p>
<h2 id="chapter-1-绪论">Chapter 1: 绪论</h2>
<h3 id="基本术语">1.1 基本术语</h3>
<blockquote>
<p>假定我们收集了一批关于西瓜的数据, 例如(色泽 = 浅白; 根蒂 = 蜷缩; 敲声
= 浊响), (色泽 = 乌黑; 根蒂 = 稍蜷; 敲声 = 沉闷), (色泽 = 浅白; 根蒂 =
硬挺; 敲声 = 清脆), ......, 每对括号内是一条记录,
下文关于术语的表述会基于上述假定进行解释.</p>
</blockquote>
<ul>
<li><p><strong>数据集/样本(Data Set):</strong>
这组记录的集合称为一个数据集.</p>
<blockquote>
<p><strong>Tips:</strong> 数据集亦称样本,
因为数据集可看作对样本空间的一个采样.</p>
<p><strong>Addtional:</strong> "样本"的具体指代示例还是数据集,
要看具体的上下文.</p>
</blockquote></li>
<li><p><strong>示例(Instance)/样本(Sample):</strong>
每条记录称为示例/样本, 是关于一个事件或对象的描述(以上例,
该对象为西瓜).</p></li>
<li><p><strong>属性(Attribute)/特征(Feature):</strong> "色泽", "根蒂",
"敲声"称为属性.</p></li>
<li><p><strong>属性值(Attribute Value):</strong>
属性的取值称为属性值(以上例, "青绿"和"乌黑"是色泽的属性值).</p></li>
<li><p><strong>属性空间(Attribute Space)/样本空间(Sample
Space)/输入空间:</strong> 属性张成的空间.</p>
<blockquote>
<p><strong>Tips:</strong> 此处涉及的是线性代数知识,
即将样本(Instance)依据属性转化为向量, 其中色泽, 根蒂和敲声为坐标轴,
张成了一个用于描述西瓜特征的三维空间,
该空间每个点即是线性代数意义上的一个向量, 也就是<strong>特征向量(Feature
Vector)</strong>. 我们可以认为,
示例(Instance)的另一种等价表述是特征向量.</p>
</blockquote></li>
<li><p><strong>数据集的表示:</strong> 令 <span
class="math inline">\(\mathit{D} = \{x_1, x_2, ..., x_m\}\)</span>
表示包含<span class="math inline">\(m\)</span>个示例的数据集, 每个示例由
<span class="math inline">\(d\)</span> 个属性描述, 则每个示例(Instance)
<span class="math inline">\(x_i= (x_{i1}; x_{i2}; ...; x_{id})\)</span>
是 <span class="math inline">\(d\)</span> 维样本空间 <span
class="math inline">\(\mathcal{X}\)</span> 中的一个向量, <span
class="math inline">\(x_i \in \mathcal{X}\)</span>. <span
class="math inline">\(d\)</span> 称为样本 <span
class="math inline">\(x_i\)</span>
的<strong>维数(Dimensionality)</strong>.</p></li>
<li><p><strong>学习(Learning)/训练(Training):</strong>
从数据中学得模型的过程称为学习/训练,
该过程通过执行某个学习算法完成.</p></li>
<li><p><strong>训练数据(Training Data):</strong>
训练过程中所使用的数据.</p></li>
<li><p><strong>训练样本(Training Sample)/训练示例(Training
Instance):</strong> 训练数据中的每个样本/示例.</p></li>
<li><p><strong>训练集(Training Set):</strong>
训练样本组成的集合称为训练集.</p>
<blockquote>
<p><strong>Tips:</strong> 训练集相当于训练数据的子集,
训练数据除去<strong>训练集</strong>外还存在<strong>验证集</strong>.(参考自:<a
href="https://zhuanlan.zhihu.com/p/115344944"><strong>知乎|训练集(training
dataset), 测试集(test dataset)与验证集(validation
dataset)</strong></a>)</p>
</blockquote></li>
<li><p><strong>假设(Hypothesis)&amp;真相/真实(Ground-Truth):</strong>
学得模型对应了关于数据的某种潜在规律,
因此亦称假设.这种潜在规律称为"真相"/"真实".
学习的过程就是为了找出或逼近真相.</p>
<blockquote>
<p><strong>Tips:</strong> <a
href="https://en.wikipedia.org/wiki/Ground_truth"><strong>WIKIPEDIA|Ground-Truth</strong></a>又将其表述为<strong>基准真相</strong>.</p>
<p>"Ground truth is information that is known to be real or true,
provided by direct observation and measurement (i.e. empirical evidence)
as opposed to information provided by inference."</p>
</blockquote></li>
</ul>
<p><strong>Tips:</strong>
本书有时又将<strong>模型</strong>称为<strong>学习器(Learner)</strong>,
模型可看作是学习算法在给定数据和参数空间上的实例化.</p>
<ul>
<li><p><strong>标记(Label):</strong> 关于示例(Instance)结果的信息,
称为标记(如"好瓜"). 一般的, 用 <span class="math inline">\((x_i,
y_i)\)</span> 表示第 <span class="math inline">\(i\)</span> 个样例, 其中
<span class="math inline">\(y_i \in \mathcal{Y}\)</span> 是示例 <span
class="math inline">\(x_i\)</span> 的标记, <span
class="math inline">\(\mathcal{Y}\)</span> 是所有标记的集合,
又称<strong>标记空间(Label Space)/输出空间</strong>.</p></li>
<li><p><strong>分类(Classification):</strong>
若<strong>预测(Prediction)</strong>的是离散值(如"好瓜", "坏瓜"),
则称此类学习任务是分类.</p></li>
<li><p><strong>回归(Regression):</strong> 若预测的是连续值(如成熟度0.95,
0.7), 则称此类学习任务是回归.</p></li>
<li><p><strong>二分类(Binary Classification):</strong>
只涉及两个类别的分类任务, 通常称其中一类为<strong>正类(Positive
Class)</strong>, 另一类为<strong>反类(Negative Class)</strong>.</p></li>
<li><p><strong>多分类(Multi-class Classification):</strong> 与之相对的,
涉及多种类别的分类任务称为多分类任务.</p></li>
<li><p><strong>预测任务:</strong> 预测任务希望通过对训练集<span
class="math inline">\(\{(x_1, y_1), (x_2, y_2), ..., (x_m,
y_m)\}\)</span> 进行学习, 建立一个从输入空间 <span
class="math inline">\(\mathcal{X}\)</span> 到输出空间 <span
class="math inline">\(\mathcal{Y}\)</span> 的映射 <span
class="math inline">\(f : \mathcal{X} \rightarrow \mathcal{Y}\)</span>.
对二分类, 通常取 <span class="math inline">\(\mathcal{Y} = \{-1,
1\}\)</span> 或 <span class="math inline">\(\{0, 1\}\)</span>;
对于多分类, <span class="math inline">\(|\mathcal{Y}| &gt; 2\)</span>;
对于回归, <span class="math inline">\(\mathcal{Y} =
\mathbb{R}\)</span>.</p></li>
<li><p><strong>测试(Testing):</strong>
使用学习得到的模型进行预测的过程称为测试,
预测的样本称为<strong>测试样本(Testing Sample)/测试示例(Testing
Instance)</strong>.</p></li>
<li><p><strong>聚类(Clustering):</strong> 将训练集中的样本分为若干组,
每组称为一个<strong>簇(Cluster)</strong>.</p>
<blockquote>
<p><strong>Tips:</strong> 形成的簇可能对应一些潜在的概念划分(如本地瓜,
外地瓜), 但这样的概念我们事先不知道,
否则通过标记(Label)就可以形成簇划分.</p>
</blockquote></li>
<li><p><strong>监督学习(Supervised Learning)/有导师学习:</strong>
训练数据拥有标记信息, 分类和回归为代表.</p></li>
<li><p><strong>无监督学习(Unsupervised Learning)/无导师学习</strong>
训练数据无标记信息, 聚类为代表.</p></li>
</ul>
<blockquote>
<p><strong>Tips:</strong> 此处仅作最基本的概念了解,
关于上述两概念的具体释义留及之后的学习.</p>
</blockquote>
<ul>
<li><p><strong>泛化(Generalization):</strong>
学得模型适用于新样本的能力,称为泛化能力.</p>
<blockquote>
<p><strong>Tips1:</strong> 样本空间通常很大, 训练过程无法涵盖所有的示例,
我们希望模型可以对新样本有较好的目标表现, 这就是泛化的意义.</p>
<p><strong>Tips2:</strong> 泛化的数学支撑:</p>
<p>关于这种泛化,
我们通常假设样本空间中的所有样本都服从一个未知的<strong>分布(Distribution)</strong>
<span class="math inline">\(\mathcal{D}\)</span>,
获取的样本是从该分布上采样获得的, 满足<strong>独立同分布(Independent and
Identically Distributed, <em>i.d.d</em>)</strong>.</p>
</blockquote></li>
</ul>
<h3 id="假设空间">1.3 假设空间</h3>
<p><strong>归纳(Induction)</strong>与<strong>演绎(Deduction)</strong>是科学推理的两大基本手段.</p>
<blockquote>
<p>前者是从特殊到一般的<strong>泛化(Generalization)</strong>过程;
后者是从一般到特殊的<strong>特化(Specialization)</strong>过程.</p>
</blockquote>
<ul>
<li><p><strong>归纳学习(Inductive Learning):</strong>
广义的归纳学习大体相当于从样例中学习,
狭义的归纳学习要求从学习过程中习得<strong>概念(concept)</strong>,
亦称<strong>概念学习/概念形成</strong>.</p></li>
<li><p><strong>版本空间(Version Space):</strong>
存在一个与训练集一致的"假设集合", 称为版本空间, 例如:</p></li>
</ul>
<img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/table1-1.png" class="" title="table1-1">
<p>其假设空间为</p>
<img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-1.png" class="" title="pic1-1">
<p>其版本空间为</p>
<img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-2.png" class="" title="pic1-2">
<blockquote>
<p><strong>Tips:</strong> 在该数据集中, 好瓜具有的共同特征是蜷缩和浊响.
因此色泽标识为通配符 <span class="math inline">\(*\)</span>, 同时,
第一行的两种假设同样是与训练集一致的(可以匹配好瓜).</p>
</blockquote>
<h3 id="归纳偏好">1.4 归纳偏好</h3>
<ul>
<li><p><strong>归纳偏好(Inductive bias):</strong>
算法在学习过程中对某种类型假设的偏好称为归纳偏好.</p>
<blockquote>
<p><strong>Tips:</strong>
<strong>任何</strong>一个有效的机器学习算法必有其归纳偏好,
否则它无法产生确定的学习结果.</p>
<p>以图1-2的版本空间为例, 对新瓜(色泽=青绿;根蒂=蜷缩;敲声=沉闷),
若模型告诉我们这种瓜时好时坏则没有意义,
模型必须对给定的样本给予确定的结果.</p>
<p><strong>Additional:</strong>
归纳偏好可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或"价值观".
常遵循<strong>奥卡姆剃刀(Occam's
Razor)</strong>原则(<strong>若有多个假设与观察一致,
则选简单的那个</strong>).</p>
</blockquote></li>
</ul>
<p>接下来我们来比较不同归纳偏好的优劣</p>
<img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-3.png" class="" title="pic1-3">
<p>从直观上看我们一般会认为, 拟合出平滑的曲线A要优于曲线B, 但很遗憾,
当面临一些极端数据时, 曲线B可能会优于曲线A, 情形如下图所示.</p>
<img src="/2024/09/18/BookNote-MachineLearning-by-ZhihuaZhou-1/pic1-4.png" class="" title="pic1-4">
<p>接下来我们用数学语言尝试量化模型的优劣.</p>
<p>假设样本空间 <span class="math inline">\(\mathcal{X}\)</span>
和假设空间 <span class="math inline">\(\mathcal{H}\)</span> 都是离散的,
令 <span class="math inline">\(P(h|X, \mathfrak{L})\)</span>
代表学习算法 <span class="math inline">\(\mathfrak{L}_a\)</span>
基于训练数据 <span class="math inline">\(X\)</span> 产生假设 <span
class="math inline">\(h\)</span> 的概率, 令 <span
class="math inline">\(f\)</span> 为目标函数.则 <span
class="math inline">\(\mathfrak{L}_a\)</span>
在训练集外的所有样本上的误差为</p>
<p><span class="math display">\[\begin{equation} \label{eq1.1}
E_{ote}(\mathfrak{L}_a|X, f) = \sum_h \sum_{x \in \mathcal{X} -X} P(x)
\mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)
\tag{1.1}
\end{equation}\]</span></p>
<blockquote>
<p><strong>Tips:</strong>
以下是笔者个人对该公式的理解,可能存在疏漏或错误.</p>
<p>首先看乘起来的的三个式子, <span
class="math inline">\(\mathbb{I}\)</span> 为指示函数, 代表的含义是假设
<span class="math inline">\(h\)</span> 与目标函数 <span
class="math inline">\(f\)</span> 没有误差时取0, 存在误差时取1. 若取1,
则两个概率乘积表示在给定的<span class="math inline">\(x\)</span>和<span
class="math inline">\(h\)</span>下, 存在误差的概率.</p>
<p>接下来的两个求和就不难理解了, 分别是对<span
class="math inline">\(x\)</span>的所有取值求和以及对<span
class="math inline">\(h\)</span>的所有取值求和, 权重为特定<span
class="math inline">\(x\)</span>和<span
class="math inline">\(h\)</span>的概率.</p>
</blockquote>
<p>为简化问题, 考虑二分类, 真实目标函数<span
class="math inline">\(f\)</span>可以是任何函数<span
class="math inline">\(\mathcal{X} \rightarrow \{0,1\}\)</span>,
函数空间<span class="math inline">\(\{0,1\}^{|\mathcal{X}|}\)</span>.
对所有可能的<span
class="math inline">\(f\)</span>按均匀分布对误差求和,有</p>
<p><span class="math display">\[
\begin{align} \nonumber
\sum_f E_{ote}(\mathfrak{L}_a|x, f) &amp;= \sum_f \sum_h \sum_{x \in
\mathcal{X} -X} P(x) \mathbb{I}(h(x) \neq f(x)) P(h|X, \mathfrak{L}_a)\\
\nonumber
&amp;= \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)
\sum_f \mathbb{I}(h(x) \neq f(x))\\ \nonumber
^*&amp;=  \sum_{x \in \mathcal{X} -X} P(x) \sum_h P(h|X, \mathfrak{L}_a)
\frac{1}{2}2^{|\mathcal{X}|}\\ \nonumber
&amp;= \frac{1}{2}2^{|\mathcal{X}|} \sum_{x \in \mathcal{X} -X} P(x)
\cdot 1 \tag{1.2}
\end{align}
\]</span></p>
<blockquote>
<p><strong>Tips:</strong> 标识<span
class="math inline">\(*\)</span>的一步因为若<span
class="math inline">\(f\)</span>均匀分布, 则有一半的<span
class="math inline">\(f\)</span>对<span
class="math inline">\(x\)</span>的预测与<span
class="math inline">\(h(x)\)</span>不一致.</p>
</blockquote>
<p>式(1.2)指出, 误差与学习算法<span
class="math inline">\(\mathfrak{L}\)</span>无关! 对于任意学习算法<span
class="math inline">\(\mathfrak{L}_a\)</span>和<span
class="math inline">\(mathfrak{L}_b\)</span>,有</p>
<p><span class="math display">\[\begin{equation}
\sum_f E_{ote}(\mathfrak{L}_a|X, f) = \sum_f E_{ote}(\mathfrak{L}_b|X,
f) \tag{1.3}
\end{equation}\]</span></p>
<p>这简直糟糕透了, 似乎所有的学习算法期望性能居然都相同.
这就是<strong>没有免费午餐定理(No Free Lunch Theorem, NFL)</strong>.</p>
<blockquote>
<p><strong>Tips:</strong> 原书的证明是多重假设下的简化论述,
对严格数学证明感兴趣的读者可以自行查阅相关资料.</p>
</blockquote>
<p>但是, NFL定理有一个重要前提, 它假定了所有问题出现的机会相等,
所有问题同等重要(例如上述证明中假设了<span
class="math inline">\(f\)</span>均匀分布).
但我们并不要求模型对所有情况都能给出一个好的解决方案,
往往我们希望模型对特定问题表现是好的.</p>
<blockquote>
<p><strong>Tips:</strong> 原书中举了一个简单的例子,
骑自行车从南京鼓楼到南京新街口显然是好方案(距离约两站地铁),
但骑自行车从南京鼓楼到北京新街口, 显然不是好的方案,但我们不care.</p>
</blockquote>
<p>简单来说,
NFL定理指出了<strong>没有一种机器学习算法是适用于所有情况的</strong>,
只有针对具体问题, 才能谈论模型的优劣.</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>千里之行，始于足下</title>
    <url>/2024/09/08/hello-world/</url>
    <content><![CDATA[<p><strong>A journey of a thousand miles begins with a single
step.</strong></p>
<span id="more"></span>
<img src="/2024/09/08/hello-world/picture.png" class="" title="picture">
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode个人题解[C++] P4 寻找两个正序数组的中位数</title>
    <url>/2024/09/21/LeetCode-P4/</url>
    <content><![CDATA[<p><strong>题目链接:</strong> <a
href="https://leetcode.cn/problems/median-of-two-sorted-arrays/"><strong>LeetCode|4.寻找两个正序数组的中位数</strong></a></p>
<span id="more"></span>
<hr />
<h2 id="题面解释">题面解释</h2>
<p>找出两个有序数组合并后的中位数. 但要求时间复杂度<span
class="math inline">\(\mathit{O}(log(m + n))\)</span>.</p>
<h2 id="解法一-二分">解法一 二分</h2>
<p>笔者看到复杂度<span class="math inline">\(\mathit{O}(log(m +
n))\)</span>第一想法便是二分, 但怎么二分? 两个数组只是内部有序,
两个数组并不有序, 常规对数组二分的思路肯定是不行的.</p>
<p>那该如何进行二分呢, 对答案进行二分. 令k为所寻找的k阶数, 初始为中位数,
则此时我们取两个数组的前<span
class="math inline">\(k/2\)</span>部分出来, 比较<span
class="math inline">\(nums1[k/2]\)</span>和<span
class="math inline">\(nums2[k/2]\)</span>, 则可以直接排除<span
class="math inline">\(k/2\)</span>个数. 我们以下图例子来解释.</p>
<img src="/2024/09/21/LeetCode-P4/p1.png" class="" title="p1">
<p><span class="math inline">\(m = n = 4\)</span>, 我们有 <span
class="math inline">\(k = 4, k/2 = 2\)</span>,
于是我们取两个数组的前两位, 比较3和5, 不难看出, 1和3不可能是中位数.
为什么? 因为1和3的阶必定小于<span class="math inline">\(k = 4\)</span>,
即便第一个数组的3比第二个数组的5前面所有数都大, 3的阶也只能是3,
1就更不必说了. 而5前面的数可能大于3后面的数(例子中未能体现,
读者可以自行构造一个满足这种情况的简单例子). 因此通过这种操作,
我们可以排掉 <span class="math inline">\(k/2\)</span>
个不可能是中位数的元素, 接着我们令<span class="math inline">\(k = k -
k/2\)</span>, 将被排除的数去掉, 重新进行上述过程.</p>
<img src="/2024/09/21/LeetCode-P4/p2.png" class="" title="p2">
<p>选取两个数组的前1位.比较2 和 4, 可以排除掉2. 此时过程进行到了边界处,
接下来<span class="math inline">\(k = 1\)</span>无法继续了.
而此时剩下的4和5正是我们需要的中位数.</p>
<blockquote>
<p><strong>Tips:</strong> 为什么第二个数组不是选择2, 5, 7?</p>
<p>因为我们在上面的步骤中无法确定2和5是中位数与否, 此时的有效信息不足.
而把2 5 7都放进来与4进行比较会出现bug, 以上例, 4会被错误的排除掉</p>
</blockquote>
<p>k为奇数时情况稍有不同, 但大多是一些细节问题, 笔者在此不再赘述.
推荐读者自己构建一个例子去推算上面的过程, 相信不难理解其中要义.</p>
<p>每次排除<span class="math inline">\(k/2\)</span>, 而 <span
class="math inline">\(k = (m + n + 1) / 2\)</span>, 故时间复杂度<span
class="math inline">\(\mathit{O}(log(m + n))\)</span>.</p>
<p>参考代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; m; i++)&#123;cout &lt;&lt; nums1[i] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int j = 0; j &lt; n; j++)&#123;cout &lt;&lt; nums2[j] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = (m + n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// 排除掉小于中位数的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组被清空</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> mid = k &gt;&gt; <span class="number">1</span>; <span class="comment">// 注意循环条件 k &gt; 1</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid1 = left1 + mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> mid2 = left2 + mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 边界情况，剩余数组大小不足k</span></span><br><span class="line">            <span class="keyword">if</span> (left1 + mid &gt; m) &#123; <span class="comment">// 等价于 left1 + mid - 1 &gt;= m</span></span><br><span class="line">                mid1 = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 + mid &gt; n) &#123;</span><br><span class="line">                mid2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[mid1] &gt;= nums2[mid2]) &#123;</span><br><span class="line">                k -= mid2 - left2 + <span class="number">1</span>; <span class="comment">// 一轮可以排除掉一半</span></span><br><span class="line">                left2 = mid2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= mid1 - left1 + <span class="number">1</span>;</span><br><span class="line">                left1 = mid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 k == 1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                    left2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 别忘了处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> ((m + n) &amp; <span class="number">1</span> == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="built_in">return</span> (nums2[left2] + nums2[left2 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[left1] + nums1[left1 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num1;</span><br><span class="line">            <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                num1 = nums2[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = nums1[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num2;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                num2 = nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                num2 = nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num2 = <span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (num1 + num2) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips:</strong> 本题思路并不难想出或者说并不难理解,
但非常考验代码功底, 对细节和边界情况的考察更像是此题的侧重点.
还望看到此处的读者能静下心来调试代码, 祝早日AC.</p>
</blockquote>
<h2 id="解法二-分割">解法二 分割</h2>
<blockquote>
<p>笔者阅读题解时注意到的巧妙的解法, 原链接在此<a
href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/"><strong>P4|windliang</strong></a></p>
</blockquote>
<p>更详细的数学证明, 思路和代码请阅读原文,
笔者在此只给出自己对其的理解.</p>
<p>本质来说, 两种方法殊途同归, 但分割的方法较为巧妙一些. 中位数,
或者说k阶数, 就是将数组分为两个部分, 其一是比k阶数小的部分,
其二是比k阶数大的部分.</p>
<p>对于有序的一个数组, 其性质本身就已经满足,
我们不妨将两部分简称为左半部分(小)和右半部分(大). 对于两个有序数组,
情况是一样的, 如果存在一种划分, 满足左边最大MaxLeft小于右边最小MinRight,
我们则认为这是关于k阶数的一种有效划分.</p>
<p>因此, 这道题就被转化为寻找数组中满足中位数的有效划分,
关于特定k阶数划分, 还需要满足左半部分和右半部分的数量关系,
若规定将k阶数划在左半部分, 则左半部分有k个元素, 右半部分有 n - k
个元素.</p>
<p>后面的事情就简单了, 固定数组1的划分位置,
根据数量关系找到数组2待判定划分位置,
根据MaxLeft和MinRight的大小关系决定数组1划分位置的左移或右移,
该过程可以通过二分完成.</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
</search>
