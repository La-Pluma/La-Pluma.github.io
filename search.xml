<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>千里之行，始于足下</title>
    <url>/2024/09/08/hello-world/</url>
    <content><![CDATA[<p><strong>A journey of a thousand miles begins with a single
step.</strong></p>
<span id="more"></span>
<img src="/2024/09/08/hello-world/picture.png" class="" title="picture">
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode个人题解[C++] P4 寻找两个正序数组的中位数</title>
    <url>/2024/09/21/LeetCode-P4/</url>
    <content><![CDATA[<p><strong>题目链接:</strong> <a
href="https://leetcode.cn/problems/median-of-two-sorted-arrays/"><strong>LeetCode|4.寻找两个正序数组的中位数</strong></a></p>
<span id="more"></span>
<hr />
<h2 id="题面解释">题面解释</h2>
<p>找出两个有序数组合并后的中位数. 但要求时间复杂度<span
class="math inline">\(\mathit{O}(log(m + n))\)</span>.</p>
<h2 id="解法一-二分">解法一 二分</h2>
<p>笔者看到复杂度<span class="math inline">\(\mathit{O}(log(m +
n))\)</span>第一想法便是二分, 但怎么二分? 两个数组只是内部有序,
两个数组并不有序, 常规对数组二分的思路肯定是不行的.</p>
<p>那该如何进行二分呢, 对答案进行二分. 令k为所寻找的k阶数, 初始为中位数,
则此时我们取两个数组的前<span
class="math inline">\(k/2\)</span>部分出来, 比较<span
class="math inline">\(nums1[k/2]\)</span>和<span
class="math inline">\(nums2[k/2]\)</span>, 则可以直接排除<span
class="math inline">\(k/2\)</span>个数. 我们以下图例子来解释.</p>
<img src="/2024/09/21/LeetCode-P4/p1.png" class="" title="p1">
<p><span class="math inline">\(m = n = 4\)</span>, 我们有 <span
class="math inline">\(k = 4, k/2 = 2\)</span>,
于是我们取两个数组的前两位, 比较3和5, 不难看出, 1和3不可能是中位数.
为什么? 因为1和3的阶必定小于<span class="math inline">\(k = 4\)</span>,
即便第一个数组的3比第二个数组的5前面所有数都大, 3的阶也只能是3,
1就更不必说了. 而5前面的数可能大于3后面的数(例子中未能体现,
读者可以自行构造一个满足这种情况的简单例子). 因此通过这种操作,
我们可以排掉 <span class="math inline">\(k/2\)</span>
个不可能是中位数的元素, 接着我们令<span class="math inline">\(k = k -
k/2\)</span>, 将被排除的数去掉, 重新进行上述过程.</p>
<img src="/2024/09/21/LeetCode-P4/p2.png" class="" title="p2">
<p>选取两个数组的前1位(为什么第二个数组不是选择2, 5, 7?
因为我们在上面的步骤中无法确定2和5是中位数与否, 此时的有效信息不足.
而把2 5 7都放进来与4进行比较会出现bug, 以上例, 4会被错误的排除掉).比较2
和 4, 可以排除掉2. 此时过程进行到了边界处, 接下来<span
class="math inline">\(k = 1\)</span>无法继续了.
而此时剩下的4和5正是我们需要的中位数.</p>
<p>k为奇数时情况稍有不同, 但大多是一些细节问题, 笔者在此不再赘述.
推荐读者自己构建一个例子去推算上面的过程, 相信不难理解其中要义.</p>
<p>每次排除<span class="math inline">\(k/2\)</span>, 而 <span
class="math inline">\(k = (m + n + 1) / 2\)</span>, 故时间复杂度<span
class="math inline">\(\mathit{O}(log(m + n))\)</span>.</p>
<p>参考代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; m; i++)&#123;cout &lt;&lt; nums1[i] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//for(int j = 0; j &lt; n; j++)&#123;cout &lt;&lt; nums2[j] &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> k = (m + n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// 排除掉小于中位数的数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 一个数组被清空</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1 += k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> mid = k &gt;&gt; <span class="number">1</span>; <span class="comment">// 注意循环条件 k &gt; 1</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid1 = left1 + mid - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> mid2 = left2 + mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 边界情况，剩余数组大小不足k</span></span><br><span class="line">            <span class="keyword">if</span> (left1 + mid &gt; m) &#123; <span class="comment">// 等价于 left1 + mid - 1 &gt;= m</span></span><br><span class="line">                mid1 = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 + mid &gt; n) &#123;</span><br><span class="line">                mid2 = n - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums1[mid1] &gt;= nums2[mid2]) &#123;</span><br><span class="line">                k -= mid2 - left2 + <span class="number">1</span>; <span class="comment">// 一轮可以排除掉一半</span></span><br><span class="line">                left2 = mid2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= mid1 - left1 + <span class="number">1</span>;</span><br><span class="line">                left1 = mid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 k == 1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                left1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                    left2++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 别忘了处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> ((m + n) &amp; <span class="number">1</span> == <span class="number">1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数</span></span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                <span class="built_in">return</span> (nums2[left2] + nums2[left2 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> (nums1[left1] + nums1[left1 + <span class="number">1</span>]) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> num1;</span><br><span class="line">            <span class="keyword">if</span> (nums1[left1] &gt;= nums2[left2]) &#123;</span><br><span class="line">                num1 = nums2[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = nums1[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num2;</span><br><span class="line">            <span class="keyword">if</span> (left1 == m) &#123;</span><br><span class="line">                num2 = nums2[left2];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left2 == n) &#123;</span><br><span class="line">                num2 = nums1[left1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num2 = <span class="built_in">min</span>(nums1[left1], nums2[left2]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (num1 + num2) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tips:</strong> 本题思路并不难想出或者说并不难理解,
但非常考验代码功底, 对细节和边界情况的考察更像是此题的侧重点.
还望看到此处的读者能静下心来调试代码, 祝早日AC.</p>
</blockquote>
<h2 id="解法二-分割">解法二 分割</h2>
<blockquote>
<p>笔者阅读题解时注意到的巧妙的解法, 原链接在此<a
href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/8999/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/"><strong>P4|windliang</strong></a></p>
</blockquote>
<p>更详细的数学证明, 思路和代码请阅读原文,
笔者在此只给出自己对其的理解.</p>
<p>本质来说, 两种方法殊途同归, 但分割的方法较为巧妙一些, 中位数,
或者说k阶数, 就是将数组分为两个部分, 其一是比k阶数小的部分,
其二是比k阶数大的部分. 对于有序的一个数组, 其性质本身就已经满足,
我们不妨将两部分简称为左半部分(小)和右半部分(大). 对于两个有序数组,
情况是一样的, 如果存在一种划分, 满足左边最大MaxLeft小于右边最小MinRight,
我们则认为这是关于k阶数的一种有效划分.</p>
<p>因此, 这道题就被转化为寻找数组中满足中位数的有效划分,
关于特定k阶数划分, 还需要满足左半部分和右半部分的数量关系,
若规定将k阶数划在左半部分, 则左半部分有k个元素, 右半部分有 n - k
个元素.</p>
<p>后面的事情就简单了, 固定数组1的划分位置,
根据数量关系找到数组2待判定划分位置,
根据MaxLeft和MinRight的大小关系决定数组1划分位置的左移或右移,
该过程可以通过二分完成.</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二分</tag>
      </tags>
  </entry>
</search>
